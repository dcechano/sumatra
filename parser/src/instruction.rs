use std::convert::TryFrom;

use anyhow::{bail, Result};
use byteorder::ReadBytesExt;

use crate::{
    class_reader::ClassReader,
    instruction::{
        ArrayType::{Boolean, Byte, Char, Double, Dummy, Float, Int, Long, Short},
        Instruction::*,
        WideInstruction::Invalid,
    },
};

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum Instruction {
    AaLoad,
    AaStore,
    AaConstNull,
    ALoad(u8),
    ALoad0,
    ALoad1,
    ALoad2,
    ALoad3,
    ANewArray(u16),
    AReturn,
    ArrayLength,
    /// Store reference into local variable 
    AStore(u8),
    /// Store reference into local variable 
    AStore0,
    AStore1,
    AStore2,
    AStore3,
    AThrow,
    BaLoad,
    BaStore,
    BiPush(i8),
    CaLoad,
    CaStore,
    Checkcast(u16),
    D2F,
    D2I,
    D2L,
    DAdd,
    DaLoad,
    DaStore,
    Dcmpg,
    Dcmpl,
    DConst0,
    DConst1,
    DDiv,
    DLoad(u8),
    DLoad0,
    DLoad1,
    DLoad2,
    DLoad3,
    DMul,
    DNeg,
    DRem,
    DReturn,
    DStore(u8),
    DStore0,
    DStore1,
    DStore2,
    DStore3,
    DSub,
    Dup,
    DupX1,
    DupX2,
    Dup2,
    Dup2X1,
    Dup2X2,
    F2D,
    F2I,
    F2L,
    FAdd,
    FaLoad,
    FaStore,
    Fcmpg,
    Fcmpl,
    FConst0,
    FConst1,
    FConst2,
    FDiv,
    FLoad(u8),
    FLoad0,
    FLoad1,
    FLoad2,
    FLoad3,
    FMul,
    FNeg,
    FRem,
    FReturn,
    FStore(u8),
    FStore0,
    FStore1,
    FStore2,
    FStore3,
    FSub,
    GetField(u16),
    /// get `static` field from class and add to stack,
    /// where the operand is index of class in the constant pool.
    GetStatic(usize),
    GoTo(i16),
    GoToW(i32),
    I2B,
    I2C,
    I2D,
    I2F,
    I2L,
    I2S,
    IAdd,
    IaLoad,
    IAnd,
    IaStore,
    IConstM1,
    IConst0,
    IConst1,
    IConst2,
    IConst3,
    IConst4,
    IConst5,
    IDiv,
    IfAcmpeq(i16),
    IfAcmpne(i16),
    IfIcmpeq(i16),
    IfIcmpne(i16),
    IfIcmplt(i16),
    IfIcmpge(i16),
    IfIcmpgt(i16),
    IfIcmple(i16),
    Ifeq(i16),
    Ifne(i16),
    Iflt(i16),
    Ifge(i16),
    Ifgt(i16),
    Ifle(i16),
    IfNonNull(i16),
    IfNull(i16),
    Iinc(u8, i8), // TODO double check the spec on this one. It was confusing.
    ILoad(u8),
    ILoad0,
    ILoad1,
    ILoad2,
    ILoad3,
    IMul,
    INeg,
    InstanceOf(u16),
    InvokeDynamic(u16, u8, u8), // last 2 bytes are always 0
    InvokeInterface(u16, u8, u8),
    InvokeSpecial(u16),
    /// Invoke a class (static) method.
    /// The provided u16 is an index to the run-time constant pool where the
    /// entry is a symbolic reference to a method or interface method.
    InvokeStatic(u16),
    /// Invoke instance method; dispatch based on class
    InvokeVirtual(usize),
    IOr,
    IRem,
    IReturn,
    IShL,
    IShR,
    IStore(u8),
    IStore0,
    IStore1,
    IStore2,
    IStore3,
    ISub,
    IuShR,
    IxOr,
    Jsr(i16),
    JsrW(i32),
    L2D,
    L2F,
    L2I,
    LAdd,
    LaLoad,
    LAnd,
    LaStore,
    Lcmp,
    LConst0,
    LConst1,
    /// Push item from run-time constant pool.
    Ldc(usize),
    LdcW(usize),
    Ldc2W(usize),
    LDiv,
    LLoad(u8),
    LLoad0,
    LLoad1,
    LLoad2,
    LLoad3,
    LMul,
    LNeg,
    LookUpSwitch {
        default_index: i32,
        jump_table: Vec<(i32, i32)>,
    },
    LOr,
    LRem,
    LReturn,
    LShL,
    LShR,
    LStore(u8),
    LStore0,
    LStore1,
    LStore2,
    LStore3,
    LSub,
    LuShR,
    LxOr,
    MonitorEnter,
    MonitorExit,
    MultiaNewArray(u16, u8),
    New(u16),
    NewArray(ArrayType),
    Nop,
    Pop,
    Pop2,
    PutField(u16),
    PutStatic(u16),
    Ret(u8),
    /// Used to return from a `void` method.
    Return,
    SaLoad,
    SaStore,
    SiPush(i16),
    Swap,
    TableSwitch {
        default_index: i32,
        low: i32,
        high: i32,
        jump_offsets: Vec<i32>,
    },
    Wide(WideInstruction),
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum WideInstruction {
    Iinc(u16, u16),
    ILoad(u16),
    FLoad(u16),
    ALoad(u16),
    LLoad(u16),
    DLoad(u16),
    IStore(u16),
    FStore(u16),
    AStore(u16),
    LStore(u16),
    DStore(u16),
    Ret(u16),
    Invalid,
}

impl Instruction {
    pub fn from_bytes(bytes: &[u8]) -> Result<Vec<Self>> {
        let mut cursor = ClassReader::with_buffer(bytes);
        let mut instructions = Vec::with_capacity(bytes.len());
        while cursor.position() != bytes.len() as u64 {
            let instruction = match cursor.read_u8()? {
                50 => AaLoad,
                83 => AaStore,
                1 => AaConstNull,
                25 => ALoad(cursor.read_u8()?),
                42 => ALoad0,
                43 => ALoad1,
                44 => ALoad2,
                45 => ALoad3,
                189 => ANewArray(cursor.read_u16()?),
                176 => AReturn,
                190 => ArrayLength,
                58 => AStore(cursor.read_u8()?),
                75 => AStore0,
                76 => AStore1,
                77 => AStore2,
                78 => AStore3,
                191 => AThrow,
                51 => BaLoad,
                84 => BaStore,
                16 => BiPush(cursor.read_i8()?),
                52 => CaLoad,
                85 => CaStore,
                192 => Checkcast(cursor.read_u16()?),
                144 => D2F,
                142 => D2I,
                143 => D2L,
                99 => DAdd,
                49 => DaLoad,
                82 => DaStore,
                152 => Dcmpg,
                151 => Dcmpl,
                14 => DConst0,
                15 => DConst1,
                111 => DDiv,
                24 => DLoad(cursor.read_u8()?),
                38 => DLoad0,
                39 => DLoad1,
                40 => DLoad2,
                41 => DLoad3,
                107 => DMul,
                119 => DNeg,
                115 => DRem,
                175 => DReturn,
                57 => DStore(cursor.read_u8()?),
                71 => DStore0,
                72 => DStore1,
                73 => DStore2,
                74 => DStore3,
                103 => DSub,
                89 => Dup,
                90 => DupX1,
                91 => DupX2,
                92 => Dup2,
                93 => Dup2X1,
                94 => Dup2X2,
                141 => F2D,
                139 => F2I,
                140 => F2L,
                98 => FAdd,
                48 => FaLoad,
                81 => FaStore,
                150 => Fcmpg,
                149 => Fcmpl,
                11 => FConst0,
                12 => FConst1,
                13 => FConst2,
                110 => FDiv,
                23 => FLoad(cursor.read_u8()?),
                34 => FLoad0,
                35 => FLoad1,
                36 => FLoad2,
                37 => FLoad3,
                106 => FMul,
                118 => FNeg,
                114 => FRem,
                174 => FReturn,
                56 => FStore(cursor.read_u8()?),
                67 => FStore0,
                68 => FStore1,
                69 => FStore2,
                70 => FStore3,
                102 => FSub,
                180 => GetField(cursor.read_u16()?),
                178 => GetStatic(cursor.read_u16()? as usize),
                167 => GoTo((cursor.position() - 1) as i16 + cursor.read_i16()?),
                200 => GoToW((cursor.position() - 1) as i32 + cursor.read_i32()?),
                145 => I2B,
                146 => I2C,
                135 => I2D,
                134 => I2F,
                133 => I2L,
                147 => I2S,
                96 => IAdd,
                46 => IaLoad,
                126 => IAnd,
                79 => IaStore,
                2 => IConstM1,
                3 => IConst0,
                4 => IConst1,
                5 => IConst2,
                6 => IConst3,
                7 => IConst4,
                8 => IConst5,
                108 => IDiv,
                165 => IfAcmpeq(cursor.read_i16()?),
                166 => IfAcmpne(cursor.read_i16()?),
                159 => IfIcmpeq(cursor.read_i16()?),
                160 => IfIcmpne(cursor.read_i16()?),
                161 => IfIcmplt(cursor.read_i16()?),
                162 => IfIcmpge(cursor.read_i16()?),
                163 => IfIcmpgt(cursor.read_i16()?),
                164 => IfIcmple(cursor.read_i16()?),
                153 => Ifeq(cursor.read_i16()?),
                154 => Ifne(cursor.read_i16()?),
                155 => Iflt(cursor.read_i16()?),
                156 => Ifge(cursor.read_i16()?),
                157 => Ifgt(cursor.read_i16()?),
                158 => Ifle(cursor.read_i16()?),
                199 => IfNonNull(cursor.read_i16()?),
                198 => IfNull(cursor.read_i16()?),
                132 => Iinc(cursor.read_u8()?, cursor.read_i8()?),
                21 => ILoad(cursor.read_u8()?),
                26 => ILoad0,
                27 => ILoad1,
                28 => ILoad2,
                29 => ILoad3,
                104 => IMul,
                116 => INeg,
                193 => InstanceOf(cursor.read_u16()?),
                186 => InvokeDynamic(cursor.read_u16()?, cursor.read_u8()?, cursor.read_u8()?),
                185 => InvokeInterface(cursor.read_u16()?, cursor.read_u8()?, cursor.read_u8()?),
                183 => InvokeSpecial(cursor.read_u16()?),
                184 => InvokeStatic(cursor.read_u16()?),
                182 => InvokeVirtual(cursor.read_u16()? as usize),
                128 => IOr,
                112 => IRem,
                172 => IReturn,
                120 => IShL,
                122 => IShR,
                54 => IStore(cursor.read_u8()?),
                59 => IStore0,
                60 => IStore1,
                61 => IStore2,
                62 => IStore3,
                100 => ISub,
                124 => IuShR,
                130 => IxOr,
                168 => Jsr(cursor.read_i16()?),
                201 => JsrW(cursor.read_i32()?),
                138 => L2D,
                137 => L2F,
                136 => L2I,
                97 => LAdd,
                47 => LaLoad,
                127 => LAnd,
                80 => LaStore,
                148 => Lcmp,
                9 => LConst0,
                10 => LConst1,
                18 => Ldc(cursor.read_u8()? as usize),
                19 => LdcW(cursor.read_u16()? as usize),
                20 => Ldc2W(cursor.read_u16()? as usize),
                109 => LDiv,
                22 => LLoad(cursor.read_u8()?),
                30 => LLoad0,
                31 => LLoad1,
                32 => LLoad2,
                33 => LLoad3,
                105 => LMul,
                117 => LNeg,
                171 => {
                    let pad_len = if cursor.position() % 4 == 0 {
                        0
                    } else {
                        4 - cursor.position() % 4
                    };
                    (0..pad_len)
                        .map(|_| cursor.read_u8())
                        .collect::<Result<Vec<u8>>>()?;
                    let default_index = cursor.read_i32()?;

                    let pairs = {
                        let pair_len = cursor.read_i32()?;
                        if pair_len < 0 {
                            bail!("Invalid number of pairs while parsing LookUpSwitch.");
                        }
                        let mut pairs = Vec::with_capacity(pair_len as usize);
                        for _ in 0..pair_len {
                            pairs.push((cursor.read_i32()?, cursor.read_i32()?));
                        }
                        pairs
                    };
                    LookUpSwitch {
                        default_index,
                        jump_table: pairs,
                    }
                }
                129 => LOr,
                113 => LRem,
                173 => LReturn,
                121 => LShL,
                123 => LShR,
                55 => LStore(cursor.read_u8()?),
                63 => LStore0,
                64 => LStore1,
                65 => LStore2,
                66 => LStore3,
                101 => LSub,
                125 => LuShR,
                131 => LxOr,
                194 => MonitorEnter,
                195 => MonitorExit,
                197 => MultiaNewArray(cursor.read_u16()?, cursor.read_u8()?),
                188 => NewArray(ArrayType::try_from(cursor.read_u8()?)?),
                187 => New(cursor.read_u16()?),
                0 => Nop,
                87 => Pop,
                88 => Pop2,
                181 => PutField(cursor.read_u16()?),
                179 => PutStatic(cursor.read_u16()?),
                169 => Ret(cursor.read_u8()?),
                177 => Return,
                53 => SaLoad,
                86 => SaStore,
                17 => SiPush(cursor.read_i16()?),
                95 => Swap,
                170 => {
                    let pad_len = if cursor.position() % 4 == 0 {
                        0
                    } else {
                        4 - cursor.position() % 4
                    };
                    (0..pad_len)
                        .map(|_| cursor.read_u8())
                        .collect::<Result<Vec<u8>>>()?;
                    let default_index = cursor.read_i32()?;
                    let low = cursor.read_i32()?;
                    let high = cursor.read_i32()?;
                    if low > high {
                        bail!("TableSwitch low > high invariant violated.");
                    }
                    let jump_offsets = (0..(high - low + 1))
                        .map(|_| cursor.read_i32())
                        .collect::<Result<Vec<i32>>>()?;

                    TableSwitch {
                        default_index,
                        low,
                        high,
                        jump_offsets,
                    }
                }
                196 => Wide(Self::parse_wide_opcode(&mut cursor)?),
                unknown => {
                    bail!("Unknown instruction {unknown}");
                }
            };
            instructions.push(instruction)
        }
        instructions.shrink_to_fit();
        Ok(instructions)
    }

    fn parse_wide_opcode(cursor: &mut ClassReader) -> Result<WideInstruction> {
        let mut opcode = WideInstruction::try_from(Instruction::try_from(cursor.read_u8()?)?)?;
        match opcode {
            WideInstruction::Iinc(ref mut a, ref mut b) => {
                *a = cursor.read_u16()?;
                *b = cursor.read_u16()?;
            }
            WideInstruction::ILoad(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::FLoad(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::ALoad(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::LLoad(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::DLoad(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::IStore(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::FStore(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::AStore(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::LStore(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::DStore(ref mut a) => *a = cursor.read_u16()?,
            WideInstruction::Ret(ref mut a) => *a = cursor.read_u16()?,
            invalid => bail!("Invalid Opcode for Wide instruction: {invalid:?}."),
        };
        Ok(opcode)
    }
}
impl TryFrom<u8> for Instruction {
    type Error = anyhow::Error;

    fn try_from(value: u8) -> Result<Self> {
        let instruction = match value {
            50 => AaLoad,
            83 => AaStore,
            1 => AaConstNull,
            25 => ALoad(0),
            42 => ALoad0,
            43 => ALoad1,
            44 => ALoad2,
            45 => ALoad3,
            189 => ANewArray(0),
            176 => AReturn,
            190 => ArrayLength,
            58 => AStore(0),
            75 => AStore0,
            76 => AStore1,
            77 => AStore2,
            78 => AStore3,
            191 => AThrow,
            51 => BaLoad,
            84 => BaStore,
            16 => BiPush(0),
            52 => CaLoad,
            85 => CaStore,
            192 => Checkcast(0),
            144 => D2F,
            142 => D2I,
            143 => D2L,
            99 => DAdd,
            49 => DaLoad,
            82 => DaStore,
            152 => Dcmpg,
            151 => Dcmpl,
            14 => DConst0,
            15 => DConst1,
            111 => DDiv,
            24 => DLoad(0),
            38 => DLoad0,
            39 => DLoad1,
            40 => DLoad2,
            41 => DLoad3,
            107 => DMul,
            119 => DNeg,
            115 => DRem,
            175 => DReturn,
            57 => DStore(0),
            71 => DStore0,
            72 => DStore1,
            73 => DStore2,
            74 => DStore3,
            103 => DSub,
            89 => Dup,
            90 => DupX1,
            91 => DupX2,
            92 => Dup2,
            93 => Dup2X1,
            94 => Dup2X2,
            141 => F2D,
            139 => F2I,
            140 => F2L,
            98 => FAdd,
            48 => FaLoad,
            81 => FaStore,
            150 => Fcmpg,
            149 => Fcmpl,
            11 => FConst0,
            12 => FConst0,
            13 => FConst0,
            110 => FDiv,
            23 => FLoad(0),
            34 => FLoad0,
            35 => FLoad1,
            36 => FLoad2,
            37 => FLoad3,
            106 => FMul,
            118 => FNeg,
            114 => FRem,
            174 => FReturn,
            56 => FStore(0),
            67 => FStore0,
            68 => FStore1,
            69 => FStore2,
            70 => FStore3,
            180 => GetField(0),
            178 => GetStatic(0),
            167 => GoTo(0),
            200 => GoToW(0),
            145 => I2B,
            146 => I2C,
            135 => I2D,
            133 => I2L,
            147 => I2S,
            96 => IAdd,
            46 => IaLoad,
            126 => IAnd,
            79 => IaStore,
            2 => IConstM1,
            3 => IConst0,
            4 => IConst1,
            5 => IConst2,
            6 => IConst3,
            7 => IConst4,
            8 => IConst5,
            108 => IDiv,
            165 => IfAcmpeq(0),
            166 => IfAcmpne(0),
            159 => IfIcmpeq(0),
            160 => IfIcmpne(0),
            161 => IfIcmplt(0),
            162 => IfIcmpge(0),
            163 => IfIcmpgt(0),
            164 => IfIcmple(0),
            153 => Ifeq(0),
            154 => Ifne(0),
            155 => Iflt(0),
            156 => Ifge(0),
            157 => Ifgt(0),
            158 => Ifle(0),
            199 => IfNonNull(0),
            198 => IfNull(0),
            132 => Iinc(0, 0),
            21 => ILoad(0),
            26 => ILoad0,
            27 => ILoad1,
            28 => ILoad2,
            29 => ILoad3,
            104 => IMul,
            116 => INeg,
            193 => InstanceOf(0),
            186 => InvokeDynamic(0, 0, 0),
            183 => InvokeSpecial(0),
            184 => InvokeStatic(0),
            182 => InvokeVirtual(0),
            128 => IOr,
            112 => IRem,
            172 => IReturn,
            120 => IShL,
            122 => IShR,
            54 => IStore(0),
            59 => IStore0,
            60 => IStore1,
            61 => IStore2,
            62 => IStore3,
            100 => ISub,
            124 => IuShR,
            130 => IxOr,
            168 => Jsr(0),
            201 => JsrW(0),
            138 => L2D,
            137 => L2F,
            136 => L2I,
            97 => LAdd,
            47 => LaLoad,
            127 => LAnd,
            80 => LaStore,
            148 => Lcmp,
            9 => LConst0,
            10 => LConst1,
            18 => Ldc(0),
            19 => LdcW(0),
            20 => Ldc2W(0),
            109 => LDiv,
            22 => LLoad(0),
            30 => LLoad0,
            31 => LLoad1,
            32 => LLoad2,
            33 => LLoad3,
            105 => LMul,
            117 => LNeg,
            171 => LookUpSwitch {
                default_index: 0,
                jump_table: vec![],
            },
            129 => LOr,
            113 => LRem,
            173 => LReturn,
            121 => LShL,
            123 => LShR,
            55 => LStore(0),
            63 => LStore0,
            64 => LStore1,
            65 => LStore2,
            66 => LStore3,
            101 => LSub,
            125 => LuShR,
            131 => LxOr,
            194 => MonitorEnter,
            195 => MonitorExit,
            197 => MultiaNewArray(0, 0),
            188 => NewArray(Dummy),
            0 => Nop,
            87 => Pop,
            88 => Pop2,
            181 => PutField(0),
            179 => PutStatic(0),
            169 => Ret(0),
            177 => Return,
            53 => SaLoad,
            86 => SaStore,
            17 => SiPush(0),
            95 => Swap,
            170 => TableSwitch {
                default_index: 0,
                low: 0,
                high: 0,
                jump_offsets: vec![],
            },
            196 => Wide(Invalid),
            unknown => {
                bail!("Unknown instruction {unknown}");
            }
        };
        Ok(instruction)
    }
}

impl TryFrom<Instruction> for WideInstruction {
    type Error = anyhow::Error;

    fn try_from(inst: Instruction) -> Result<Self, Self::Error> {
        let wcode = match inst {
            Iinc(_, _) => WideInstruction::Iinc(0, 0),
            ILoad(_) => WideInstruction::ILoad(0),
            FLoad(_) => WideInstruction::FLoad(0),
            ALoad(_) => WideInstruction::ALoad(0),
            LLoad(_) => WideInstruction::LLoad(0),
            DLoad(_) => WideInstruction::DLoad(0),
            IStore(_) => WideInstruction::IStore(0),
            FStore(_) => WideInstruction::FStore(0),
            AStore(_) => WideInstruction::AStore(0),
            LStore(_) => WideInstruction::LStore(0),
            DStore(_) => WideInstruction::DStore(0),
            Ret(_) => WideInstruction::Ret(0),
            invalid => bail!("Invalid Opcode for Wide instruction: {invalid:?}."),
        };
        Ok(wcode)
    }
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum ArrayType {
    Boolean,
    Char,
    Float,
    Double,
    Byte,
    Short,
    Int,
    Long,
    Dummy,
}

impl TryFrom<u8> for ArrayType {
    type Error = anyhow::Error;

    fn try_from(value: u8) -> Result<Self> {
        let array_type = match value {
            4 => Boolean,
            5 => Char,
            6 => Float,
            7 => Double,
            8 => Byte,
            9 => Short,
            10 => Int,
            11 => Long,
            invalid => {
                bail!("Invalid ArrayType tag: {invalid}");
            }
        };
        Ok(array_type)
    }
}
